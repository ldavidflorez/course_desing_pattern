@startuml Refactored Architecture
title Refactored Architecture (Design Patterns)

package Models {
    class Product {
        +id
        +name
        +category
        +price
        +to_dict()
        +from_dict()
    }

    class Category {
        +id
        +name
        +to_dict()
        +from_dict()
    }

    class Favorite {
        +user_id
        +product_id
        +to_dict()
        +from_dict()
    }

    class ProductBuilder {
        +set_name()
        +set_category()
        +set_price()
        +build()
    }

    class CategoryBuilder {
        +set_name()
        +build()
    }

    class FavoriteBuilder {
        +set_user_id()
        +set_product_id()
        +build()
    }

    ProductBuilder --> Product : builds
    CategoryBuilder --> Category : builds
    FavoriteBuilder --> Favorite : builds
}
note left of Models : Builder Pattern\nConstructores fluidos para objetos

package Repositories {
    interface IProductRepository {
        +get_all()
        +get_by_id()
        +get_by_category()
        +add()
        +save_all()
    }

    interface ICategoryRepository {
        +get_all()
        +get_by_id()
        +add()
        +save_all()
    }

    interface IFavoriteRepository {
        +get_all()
        +add()
        +save_all()
        +remove()
    }

    class JsonProductRepository {
        +get_all()
        +get_by_id()
        +get_by_category()
        +add()
        +save_all()
    }

    class JsonCategoryRepository {
        +get_all()
        +get_by_id()
        +add()
        +save_all()
    }

    class JsonFavoriteRepository {
        +get_all()
        +add()
        +save_all()
        +remove()
    }

    JsonProductRepository ..|> IProductRepository
    JsonCategoryRepository ..|> ICategoryRepository
    JsonFavoriteRepository ..|> IFavoriteRepository
}
note left of Repositories : Repository Pattern\nAbstracción de acceso a datos

package Strategies {
    interface IAuthStrategy {
        +authenticate()
    }

    class TokenAuthStrategy {
        +authenticate()
    }

    class AuthContext {
        +authenticate()
    }

    TokenAuthStrategy ..|> IAuthStrategy
    AuthContext --> IAuthStrategy : uses
}
note left of Strategies : Strategy Pattern\nAutenticación intercambiable

package Services {
    class ProductService {
        +get_all_products()
        +get_product_by_id()
        +get_products_by_category()
        +create_product()
    }

    class CategoryService {
        +get_all_categories()
        +get_category_by_id()
        +create_category()
        +delete_category()
    }

    class FavoriteService {
        +get_all_favorites()
        +add_favorite()
        +remove_favorite()
    }

    ProductService --> IProductRepository : uses
    ProductService --> ICategoryRepository : uses

    CategoryService --> ICategoryRepository : uses

    FavoriteService --> IFavoriteRepository : uses
}
note left of Services : Service Layer Pattern\nLógica de negocio separada

package Blueprints {
    class AuthDecorator {
        +token_required()
    }

    class ProductsBlueprint {
        +get_products()
        +get_product()
        +create_product()
    }

    class CategoriesBlueprint {
        +get_categories()
        +get_category()
        +create_category()
        +delete_category()
    }

    class FavoritesBlueprint {
        +get_favorites()
        +add_favorite()
        +remove_favorite()
    }

    class AuthBlueprint {
        +login()
    }

    AuthDecorator --> AuthContext : uses
    ProductsBlueprint --> AuthDecorator : decorated
    CategoriesBlueprint --> AuthDecorator : decorated
    FavoritesBlueprint --> AuthDecorator : decorated

    ProductsBlueprint --> ProductService : injects
    CategoriesBlueprint --> CategoryService : injects
    FavoritesBlueprint --> FavoriteService : injects
    AuthBlueprint --> IAuthStrategy : uses
}
note left of Blueprints : Decorator Pattern\nEnrutamiento modular con autenticación decorada

class App {
    +run()
}

class DIContainer {
    +product_repo
    +category_repo
    +favorite_repo
    +auth_context
    +product_service
    +category_service
    +favorite_service
    +wire()
}
note left of DIContainer : Dependency Injection Container\nGestión de dependencias\n(Singleton + Factory Method)

App --> DIContainer : initializes
DIContainer --> IProductRepository : creates
DIContainer --> ICategoryRepository : creates
DIContainer --> IFavoriteRepository : creates
DIContainer --> AuthContext : creates
DIContainer --> ProductService : provides
DIContainer --> CategoryService : provides
DIContainer --> FavoriteService : provides

App --> ProductsBlueprint : registers
App --> CategoriesBlueprint : registers
App --> FavoritesBlueprint : registers
App --> AuthBlueprint : registers

@enduml